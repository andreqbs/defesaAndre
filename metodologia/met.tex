\mychapter{Metodologia}
\label{Cap_3}

Este capítulo apresenta os materiais, métodos utilizados e desenvolvidos nessa pesquisa. O Sistema Computacional abordado está esquematizado na Seção 3.2, onde são mostradas a sua divisão em blocos e as inter-relações existentes entre eles. A Seção 3.3 contém algumas peculiaridades relevantes das implementações.

\section{Estudo e desenvolvimento inicial}
	
\subsection{Recursos e estratégias utilizadas no desenvolvimento}

O sistema  Windows foi adotado como sistema operacional para o desenvolvimento do aplicativo, por ser um sistema bastante difundido e familiar, no entanto, nada impede que haja portabilidade do \emph{software} para outros sistemas operacionais, pois foi utilizado a plataforma Java (versão 8) para desenvolver a parte de negócios enquanto a interface gráfica foi utilizado o moderno Java FX. A IDE de desenvolvimento do software foi o NetBeans 8.2 da Oracle. A linguagem de programação Java foi a escolhida para esse tipo de sistema, devido à facilidade na orientação a objeto, à capacidade de re-uso do código, e a experiência de desenvolvimento nessa linguagem. 

Para o desenvolvimento do software foi adotado uma metodologia ágil e quadro de desenvolvimento pode ser visualizado no GitHub. A implementação se deu através em testes, primeiramente focando problemas menores e específicos, para, então, desenvolver soluções que satisfaçam os requisitos das novas \emph{sprints} em questão. O último passo foi a ampliação do programa para o atendimento de outras classes de problemas, tornando-o mais genérico.

\subsection{Etapas do desenvolvimento}

Inicialmente, objetivou-se a implementação do algoritmo empregado pelo sistema desenvolvido por Towell e Shavlik, dividindo-a em duas sub-etapas distintas: A implementação relativa ao programa em linguagem lógica e a implementação da tradução em uma Rede Neural Artificial correspondente à linguagem lógica.

Os testes se iniciaram com RNAs aplicadas a problemas simples e específicos, para, logo em seguida generalizá-los. Na sequência, ocorreu o desenvolvimento de programas para a conversão de Linguagens Lógicas, apresentadas sob a forma de clásulas Horn. Após a integração entre as duas partes, o sistema foi a aplicado a um problema mais extenso e específico do que os anteriores.

Na fase final do desenvolvimento, foi criado um sistema genérico de para gerar padrões de entradas e saídas de acordo com o as necessidades do usuário.

O desenvolvimento do trabalho pode ser acompanhado pelo enfoque existente nas etapas que o dividiram. Foram relacionadas 12 etapas pela sua ordem cronológica no desenvolvimento, nas quais se destacaram os respectivos enfoques e descrição, conforme segue:

\begin{itemize}
	
	\item \textbf{Etapa 1 (Padrões):} - Estudo de Padrões de Projetos de software para serem aplicados ao sistema.
	
	\item \textbf{Etapa 2 (RNA específica):} - Implementações de RNAs simples, permitindo a primeira definição das técnicas de implementação de RNA a serem empregadas;  
	
	\item \textbf{Etapa 3 (\emph{Backpropagation}):} - Estudo dos algoritmos de aprendizagem neural.
	
	\item \textbf{Etapa 4 (RNA genérica):} - Versões mais aprimorada do programas de RNAs específificas, com refinamento das técnicas.
		
	\item \textbf{Etapa 5 (Interface gráfica):} - Estudo preliminar para integrar todos os módulos para o gerenciamento do sistema KBANN em um ambiente computacional;
   
	\item \textbf{Etapa 6 (Algoritmo KBANN):} - Estruturação das classes do sistema KBANN e desenvolvimento do método que engloba rotinas para o processamento da sintaxe de textos;

	\item \textbf{Etapa 7 (Conversão de dados):} - Formatação dos dados a serem aplicados em uma RNA específica, definição dos formatos dos arquivos;

	\item \textbf{Etapa 8 (Algoritmo KBANN):} - Aprimoramento dos programas anteriores permitindo a inserção das regras aplicáveis de forma genérica, segundo o algoritmo KBANN;

	\item \textbf{Etapa 9 (Algoritmo KBANN):} - Aplicação do algoritmo KBANN a exemplos específicos;

	\item \textbf{Etapa 10 (Algoritmo TopGen):} - Implementação do algoritmo TopGen para gerar novas redes;
	
	\item \textbf{Etapa 11 (Algoritmo TopGen):} - Comparação entre RNAs com e sem o emprego do algoritmo TopGen;
		
	\item \textbf{Etapa 12 (Algoritmo KBANN e TopGen):} - Testes das RNAs com utilização do algoritmo KBANN;
			
	
\end{itemize}

As etapas 1 e 5 foram importantes para a fundamentação dos seus conceitos. A partir delas, podemos destacar duas implementações preliminares importantes para a continuidade dos trabalhos, vistas na subseção X. Nas etapas 2 e 4 foram realizados estudos que definiram a função matemática mais apropriada e como a interface deveria ser implementada. As etapas 3, 6 e 9 relacionam as implementações aplicadas a exemplos especí cos. As etapas 7, 8, 10 e 11 focam o algoritmo KBANN e suas aplicações. 

\subsection{Implementações preliminares}	

Algumas implementações básicas foram necessárias para se adquirir experiência, servem como exemplo da aplicação distinta dos paradigmas IAC e IAS. O conhecimento adquirido com essas implementações ajudou a composição dos blocos das implementações subsequentes. Podemos destacar abaixo as duas implementações iniciais importantes:

(a) Utilização de exemplos variados para o treinamento das RNAs. 

(b) Emprego de regras lógicas simplificadas.

\subsubsection{Redes Neurais Artificiais simples}	

Os primeiros programas desenvolvidos neste trabalho utilizavam a topologia básica da RNA com três camadas e com poucos neurônios por camada (por exemplo: 5x3x1 ou 2x2x1). Nesse caso, pretendia-se fazer somente o treinamento da RNA, verificação de cálculos e teste estrutural da arquitetura e do algoritmo de treinamento.

Alguns exemplos simples foram utilizados, como o de reconhecimento e classificação de formas (padrões sensíveis à RNA). Na classificação de formas, um  string , ou conjunto de caracteres, é passado como entrada aos neurônios da primeira camada da RNA. Um padrão sensível à RNA po?de ser definido a partir de uma imagem básica proveniente de uma matriz de caracteres. Como exemplo do reconhecimento de imagens formadas por  strings , temos a assinatura (ou modelo) de um peixe apresentado na Figura XX, definido pelo carácter \@.

A Figura é composta por uma matriz contendo 11 linhas com 25 caracteres em cada linha, constituindo um modelo de peixe para a RNA. Variações desse modelo poderiam servir de exemplo para o treinamento da RNA. Um exemplo positivo decorre de uma forma que não é muito diferente da assinatura do peixe, como um peixe mais magro ou menor. Por outro lado, se um outro formato fosse lido pela RNA, tal como uma esfera, essa seria classificada como um exemplo negativo pelo modelo.

As estruturas matriciais foram construídas somente no sentido direto da RNA. As matrizes da RNA continham os valores dos neurônios e das conexões entre eles. Os valores matriciais de retro-propagação que existem nos demais programas, nesse caso, devido à simplicidade, foram calculados através de variáveis contendo valores originados pela aplicação direta da Regra Delta (equação 2.5).

A criação de uma interface para entrada de dados fez-se necessária com a migração para programas mais genéricos. A solução mais imediata foi a adoção de arquivos formatados contendo um conjunto de definições, que são alteráveis no programa antes da sua execução.

\subsubsection{Leitura de programas lógicos}

A leitura de programas lógicos foi útil para o estudo inicial da implementação do algoritmo de conversão KBANN. A execução, o acompanhamento e os testes dessa implementação permitiram verificar a tradução de um programa em linguagem lógica (Programa Lógico) em valores calculados segundo o KBANN e também verificar a estabilidade do Programa Lógico.
A Figura X.X representa duas regras lógicas (regras 5.1 e 5.2). A partir dessas duas regras lógicas, foram obtidas as estruturas das RNAs similares às da Figura 5.2, aplicando-se a elas os cálculos requeridos pelo algoritmo, tais como a determinação do limiar de ativação mínimo e do valor mínimo de peso de rede aceitável. Durante a convergência, as saídas das regras ("e"  e  "j") atingiram a estabilidade em poucas iterações. As entradas da RNA, nesse caso, eram valores binários atribuídos a  "a, b, c, d, f, g, h e i . Os valores de convergência foram apresentados em ponto flutuante, resultado dos cálculos do algoritmo.

O arquivo-texto utilizado continha as cláusulas lógicas descritas abaixo:

FORMULAS

As duas cláusulas contêm cinco átomos cada uma, quatro dos quais estão distribuídos em dois literais, nos seus antecedentes. O consequente de cada cláusula possui apenas um literal contendo um átomo. Durante a execução dessa implementação, foi possível alterar os números de átomos, de literais e também suas posições, quando se adicionou recursividade entre os átomos, por exemplo, o consequente  e  substituiu o antecedente  f .

\subsection{O sistema desenvolvido}	

O enfoque principal do sistema desenvolvido foi a implementação do algoritmo de conversão unidirecional do sistema KBANN estendido por modalidades. A modelagem da interface utilizada iniciou-se a partir do desenvolvimento de um editor de arquivos, com o objetivo de edição e salvamento de arquivos utilizados pelo programa. Essa interface também permite que se criem novos arquivos de informações.

\subsection{Aspectos internos do sistema}

\subsubsection{Classes que compõem o programa}

A Figura 5.3 apresenta um esquema das classes nas quais o ambiente computacional teve o seu desenvolvido baseado. Utilizamos uma classe-suporte para o trabalho com a plataforma  Windows , com atributos e métodos padronizados. A classe  ControllerRegras  instancia a classe para tratamento da programação em linguagem lógica (Classe da Programação Lógica), conforme as opções que lhe são passadas.
A classe da Programação Lógica tem como dependentes as classes de instanciação das Redes Neurais Artificiais e da Aprendizagem dessa. Por sua vez, a classe que trata da RNA pode ser derivada em RNAs menores, ou sub-RNAs, que possuem seus métodos agregados aos de aprendizagem.

\subsubsection{Casos de Uso previstos}

A Figura 5.4 contém alguns casos mais comuns de uso do ambiente computacional. Um especialista do conhecimento pode valer-se desse ambiente para aplicá-lo a um problema específico. O objetivo de aplicação pode ser: o aumento na abrangência de regras associadas ao conhecimento inicial do especialista. Cada um dos casos de uso se refere a uma etapa existente neste ciclo, proposto para o aprimoramento das regras provenientes do conhecimento.

\subsubsection{Sequência de eventos}

O diagrama da Figura 5.5 aponta para a sequência de operações iniciadas pelo usuário, que basicamente, interage através da configuração contida nos arquivos e na interface. O software realiza uma varredura do arquivo que contém as informações necessárias ao desenvolvimento de seus processos.

Como ilustra a Figura 5.5, o software interno atua na modificação da estrutura da RNA geral, quer seja pelo estabelecimento da sua topologia, quer na alteração dessa em consequência da aprendizagem. Uma vez que as operações estejam encerradas, o usuário pode consultar os arquivos produzidos e verificar os resultados.

Os passos à execução do programa podem ser resumidos desta forma:

1. Seleção dos algoritmos, das operações, dos arquivos de dados.

2 A partir dos arquivos de informações inseridos, um conjunto de dados internos de trabalho é produzido pelo programa. Nesse conjunto de dados, podem ser lidos átomos, os mundos aos quais eles pertencem, as devidas posições e recursividades entre eles. 

3 Os cálculos são executados baseados nas informações do passo 2 e se estabelecem a topologia inicial da RNA e suas sub-RNAs, havendo o seu acompanhamento. 

4 Opcionalmente, novas informações podem ser obtidas a partir da leitura de exemplos, durante o aprendizado, alterando e preparando as RNAs aos processos de inferências. 

5 Inicia-se a etapa de dedução lógica. Busca-se a computação convergente do programa, que se reflete na procura da estabilidade do sistema.

\subsubsection{Processos do sistema}

Na Figura 5.6, podemos acompanhar, de outra forma, as etapas apresentadas nos casos de uso do sistema (Figura 5.4). Também temos a visão interna da sequência de processos e a atividade de inter-relação entre as classes (Figura 5.3). Primeiramente, um programa em linguagem lógica será inserido e, conforme a configuração, ocorre o seu processamento inicial.
Existem dois processos relativos à estrutura que entram em operação após a leitura dos dados iniciais: as RNAs são instanciadas e as suas topologias iniciais são fixadas. Logo após, iniciam-se os processos de aprendizagem das RNAs, que podem alterar a forma original da estrutura da rede geral.
Após o processamento da programação, instanciam-se as RNAs correspondentes, assim como os cálculos relativos ao algoritmo em operação. A etapa de aprendizagem das RNAs é executada logo em seguida, finalizando pela obtenção de resultados. Os resultados gerados pelo programa são as RNAs após o processos de aprendizagem e o percentual de acerto obtido individualmente pelas RNAs.

\subsection{Descrição da interface}

A interface também contém um menu para seleção do algoritmo a ser usado, assim como as suas opções de operação dos algoritmos. A aparência da interface está ilustrada pela Figura X.7. A descrição da interface segue nesta seção.

\subsubsection{Painel de edição}

Os três principais arquivos, conforme círculos na Figura X.7, editáveis pela interface são:

1. O arquivo que contém os nomes dos arquivos de trabalho do ambiente computacional (pacote de arquivos).

2. O arquivo que contém o program lógico a ser trabalhado.

3. O arquivo de configuração, que contém as informações sobre como a RNA deve se comportar
durante o aprendizado.
Esses três arquivos são abertos e acessados diretamente no painel interno da interface. Não existe restrição quanto ao tipo de arquivo a ser editado. Arquivos como os de dados a serem utilizados pela RNA também podem ser trabalhados.

\subsubsection{Barra do menu}

Na barra de menu, temos as opções descritas na Tabela X.1. As sub-opções relacionadas ao tipo de algoritmo escolhido funcionam como pontos de checagem durante a execução do programa.

Haverá a execução da rotina correspondente no programa sempre que a sub-opção for selecionada e os processos de aprendizagem forem acionados.

\subsubsection{Barra de botões}

A barra de botões da interface facilita algumas operações de edição e execução dos programas. Os espaços (botões ou janela) da barra de botões foram descritos na Tabela X.2.

\subsubsection{Barra status}

A interface também conta com uma barra localizada abaixo da janela principal que serve para o acompanhamento do andamento das operações. A chamada barra de status foi dividida em três regiões: a primeira contém os arquivos que foram carregados e estão sendo trabalhados, a segunda, o algoritmo em execução, e a terceira salienta as etapas do processamento.

\subsection{Considerações sobre as implementações}	

\subsubsection{RNAs}

A maioria dos programas desenvolvidos empregaram as RNAs com o seu aprendizado executado por meio do algoritmo de retro-propagação. A escolha desse algoritmo deveu-se à sua utilização no sistema KBANN [Referencia], possibilitando a comparação de resultados. Os algoritmos que definiram as topologias de RNAs empregadas foram consequência da evolução natural das técnicas de programação.
Os valores de saída e as sinapses da RNA foram implementados por variáveis contidas nas classes Neurônio e Arestas. Quando desejamos acessar o valor contido em um neurônio específico, é utilizado um \emph{HashMap} que possui todos os objetos do tipo neurônio. Dentro de cada neurônio existe uma outra variável que identifica se ele é da camada de entrada, oculta ou saída. Na Figura X.8, é possível ver a representação dessas estruturas com as quais pode-se acessar quaisquer valor desejado no grafo neural construído.

\subsection{Entradas do Sistema}

\subsubsection{Arquivos}

Os arquivos que normalmente são utilizados pelos programas dividem-se em cinco grupos:

1. Arquivos contendo a configuração da RNA e informações de controle do programa.

2. Arquivos contendo os dados de entrada para a RNA (treinamento, validação e teste).

3. Arquivos com as informações sobre a arquitetura da RNA, normalmente os valores dos pesos e as conexo?es ativas.

4. Os arquivos com o programa lógico.

5. Outros arquivos gerados durante a execução dos programas, e.g., arquivos de avaliação de resultados e de registro ( .log ).

