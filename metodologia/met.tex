\mychapter{Metodologia}
\label{Cap_3}

Este capítulo apresenta os materiais, métodos utilizados e desenvolvidos nessa pesquisa. O Sistema Computacional abordado está esquematizado na Seção 3.2, onde são mostradas a sua divisão em blocos e as inter-relações existentes entre eles. A Seção 3.3 contém algumas peculiaridades relevantes das implementações.

\section{Estudo e desenvolvimento inicial}
	
\subsection{Recursos e estratégias utilizadas no desenvolvimento}

O sistema  Windows foi adotado como sistema operacional para o desenvolvimento do aplicativo, por ser um sistema bastante difundido e familiar, no entanto, nada impede que haja portabilidade do \emph{software} para outros sistemas operacionais, pois foi utilizado a plataforma Java (versão 8) para desenvolver a parte de negócios enquanto a interface gráfica foi utilizado o moderno Java FX. A IDE de desenvolvimento do software foi o NetBeans 8.2 da Oracle. A linguagem de programação Java foi a escolhida para esse tipo de sistema, devido à facilidade na orientação a objeto, à capacidade de re-uso do código, e a experiência de desenvolvimento nessa linguagem. 

Para o desenvolvimento do software foi adotado uma metodologia ágil e o quadro de desenvolvimento pode ser visualizado no GitHub. A implementação se deu através em testes, primeiramente focando em problemas menores e específicos, para, então, desenvolver soluções que satisfaçam os requisitos das novas \emph{sprints} em questão. O último passo foi extender o sistema para o atender outros tipos de problemas.

\subsection{Etapas do desenvolvimento}

Inicialmente, objetivou-se a implementação do algoritmo empregado pelo sistema desenvolvido por \cite{towell90} dividindo-a em duas sub-etapas distintas: A implementação relativa ao programa em linguagem lógica e a implementação da tradução em uma Rede Neural Artificial correspondente à teoria de domínio inicial.

Os testes se iniciaram com o desenvolvimento de métodos para a conversão de Linguagens Lógicas, apresentadas sob a forma de clásulas Horn. Em seguida, a construção da RNAs e aplicação em problemas simples e específicos, para, logo em seguida generalizá-los. Na sequência, ocorreu a integração entre as duas partes, o sistema foi a aplicado a um problema mais extenso e geral do que os anteriores.

Na fase final do desenvolvimento, foi criado um sistema genérico de para gerar padrões de entradas e saídas de acordo com o as necessidades do usuário.


Para o desenvolvimento do projeto baseado em sistemas híbridos para predic?a?o da doenças, foram necessárias 12 etapas. Elas estão listadas pela sua ordem cronológica no desenvolvimento, nas quais se destacaram os respectivos enfoques e descrição, conforme segue:

\begin{itemize}
	
	\item \textbf{Etapa 1 (Padrões):} - Estudo de Padrões de Projetos de software para serem aplicados a sistema esse tipo de desenvolvimento.
	
	\item \textbf{Etapa 2 (RNA específica):} - Implementações de RNAs simples, permitindo a primeira definição das técnicas de implementação de RNA a serem empregadas;  
	
	\item \textbf{Etapa 3 (\emph{Backpropagation}):} - Estudo dos algoritmos de aprendizagem neural.
	
	\item \textbf{Etapa 4 (RNA genérica):} - Versões mais aprimorada do programas de RNAs específificas, com refinamento das técnicas.
		
	\item \textbf{Etapa 5 (Interface gráfica):} - Estudo preliminar para integrar todos os módulos para o gerenciamento do sistema KBANN em um ambiente computacional;
   
	\item \textbf{Etapa 6 (Algoritmo KBANN):} - Estruturação das classes do sistema KBANN e desenvolvimento do método que engloba rotinas para o processamento da sintaxe de textos;

	\item \textbf{Etapa 7 (Conversão de dados):} - Formatação dos dados a serem aplicados em uma RNA específica, definição dos formatos dos arquivos;

	\item \textbf{Etapa 8 (Algoritmo KBANN):} - Aprimoramento dos programas anteriores permitindo a inserção das regras aplicáveis de forma genérica, segundo o algoritmo KBANN;

	\item \textbf{Etapa 9 (Algoritmo KBANN):} - Aplicação do algoritmo KBANN a exemplos específicos;

	\item \textbf{Etapa 10 (Algoritmo TopGen):} - Implementação do algoritmo TopGen para gerar novas redes;
	
	\item \textbf{Etapa 11 (Algoritmo TopGen):} - Comparação entre RNAs com e sem o emprego do algoritmo TopGen;
		
	\item \textbf{Etapa 12 (Algoritmo KBANN e TopGen):} - Testes das RNAs com utilização do algoritmo KBANN;
			
	
\end{itemize}

As etapas inicias (1 a 5) tiveram fundametal importância no trabalho, pois serviu para a fundamentação dos seus conceitos e a base para um bom desenvolvimento. A partir delas, podemos destacar duas implementações preliminares importantes para a continuidade dos trabalhos, vistas na subseção X. Nas etapas 2 e 4 foram realizados estudos que definiu a forma mais apropriada de como a interface deveria ser implementada. As etapas 3, 6 e 9 relacionam as implementações aplicadas a exemplos específicos. As etapas 7, 8, 10, 11 e 12 focam o algoritmo KBANN e suas aplicações. 

\subsection{Implementações preliminares}	

Algumas implementações básicas foram necessárias para se adquirir experiência, servem como exemplo da aplicação distinta dos paradigmas IAC e IAS. O conhecimento adquirido com essas implementações ajudou a composição dos blocos das implementações subsequentes. Podemos destacar abaixo as duas implementações iniciais importantes:

(a) Utilização de exemplos variados para o treinamento das RNAs. 

(b) Emprego de regras lógicas simplificadas.

\subsubsection{Redes Neurais Artificiais simples}	

Os primeiros programas desenvolvidos neste trabalho utilizavam a topologia básica da RNA com três camadas e com poucos neurônios por camada (por exemplo: 5x3x1 ou 2x2x1). Nesse caso, pretendia-se fazer somente o treinamento da RNA, verificação de cálculos e teste estrutural da arquitetura e do algoritmo de treinamento.

Alguns exemplos simples foram utilizados, como o de reconhecimento e classificação de dados (padrões sensíveis à RNA). Na classificação de dados, como por exemplo, foi utilizado na Figura \ref{fig:XXX} para os testes inicias. Além disso, os mesmos testes foram validados no \emph{Matlab}, tanto usando o ToolBox inteligente que é disponbilizado no software, como programando as equações matemáticas dentro dele.

 \begin{align}
A :- B, \not C \\
B :- D, F, G \\
B :- D, \not F, I \\
C :- H, J, K 
\end{align}

A Figura X é composta por cinco regras que descrevem inicialmente o modelo daquele problema em específico. Assim como foi feito no TopGen, foram retirado algumas regras desse domínio, realizado o treinamento da rede e em seguida validada. Foi possível notar que o KBANN ainda consegue classificar boa parte dos dados, mesmo não tendo um domínio completo do problema. Esse teste foi feito justamente para provar que Towell comentou em seu trabalho, que não é necessário saber a fundo sobre problema. Apesar da sua boa classifaç  contendo 11 linhas com 25 caracteres em cada linha, constituindo um modelo de peixe para a RNA. Variações desse modelo poderiam servir de exemplo para o treinamento da RNA. Um exemplo positivo decorre de uma forma que não é muito diferente da assinatura do peixe, como um peixe mais magro ou menor. Por outro lado, se um outro formato fosse lido pela RNA, tal como uma esfera, essa seria classificada como um exemplo negativo pelo modelo.

As estruturas matriciais foram construídas somente no sentido direto da RNA. As matrizes da RNA continham os valores dos neurônios e das conexões entre eles. Os valores matriciais de retro-propagação que existem nos demais programas, nesse caso, devido à simplicidade, foram calculados através de variáveis contendo valores originados pela aplicação direta da Regra Delta (equação 2.5).

A criação de uma interface para entrada de dados fez-se necessária com a migração para programas mais genéricos. A solução mais imediata foi a adoção de arquivos formatados contendo um conjunto de definições, que são alteráveis no programa antes da sua execução.

\subsubsection{Leitura de programas lógicos}

A leitura de programas lógicos foi útil para o estudo inicial da implementação do algoritmo de conversão KBANN. A execução, o acompanhamento e os testes dessa implementação permitiram verificar a tradução de um programa em linguagem lógica (Programa Lógico) em valores calculados segundo o KBANN e também verificar a estabilidade do Programa Lógico.
A Figura \ref{fig:visualizacaoGrafo} representa as regras lógicas contidas na \ref{fig:entradaKANN}. A partir dessas duas regras lógicas, foram obtidas as estruturas das RNAs similares às da Figura 5.2, aplicando-se a elas os cálculos requeridos pelo algoritmo, tais como a determinação do limiar de ativação mínimo e do valor mínimo de peso de rede aceitável. Durante a convergência, as saídas das regras ("e"  e  "j") atingiram a estabilidade em poucas iterações. As entradas da RNA, nesse caso, eram valores binários atribuídos a  "a, b, c, d, f, g, h e i . Os valores de convergência foram apresentados em ponto flutuante, resultado dos cálculos do algoritmo.

O arquivo-texto utilizado continha as cláusulas lógicas descritas abaixo:

\begin{figure}[H] 
	\begin{center}
		\caption{Representação de uma RNA a partir da base de regras.}
		\includegraphics[scale=0.5]{imagens/visualizacaoGrafo.png}
		\label{fig:visualizacaoGrafo}
	\end{center} 
\end{figure}


As duas cláusulas contêm cinco átomos cada uma, quatro dos quais estão distribuídos em dois literais, nos seus antecedentes. O consequente de cada cláusula possui apenas um literal contendo um átomo. Durante a execução dessa implementação, foi possível alterar os números de átomos, de literais e também suas posições, quando se adicionou recursividade entre os átomos, por exemplo, o consequente  e  substituiu o antecedente  f .

\subsection{O sistema desenvolvido}	

O enfoque principal do sistema desenvolvido foi a implementação do algoritmo de conversão unidirecional do sistema KBANN estendido por modalidades. A modelagem da interface utilizada iniciou-se a partir do desenvolvimento de um editor de arquivos, com o objetivo de edição e salvamento de arquivos utilizados pelo programa. Essa interface também permite que se criem novos arquivos de informações.

\subsection{Aspectos internos do sistema}

\subsubsection{Classes que compõem o programa}

A Figura \ref{fig:diagramaClasses} apresenta um esquema das classes nas quais o ambiente computacional teve o seu desenvolvido baseado. Utilizamos uma classe-suporte para o trabalho com a plataforma  Windows , com atributos e métodos padronizados. A classe  ControllerRegras  instancia a classe para tratamento da programação em linguagem lógica (Classe da Programação Lógica), conforme as opções que lhe são passadas.
A classe da Programação Lógica tem como dependentes as classes de instanciação das Redes Neurais Artificiais e da Aprendizagem dessa. Por sua vez, a classe que trata da RNA pode ser derivada em RNAs menores, ou sub-RNAs, que possuem seus métodos agregados aos de aprendizagem.

\begin{figure}[H] 
	\begin{center}
		\caption{Representação parcial do diagrama de classes do sistema.}
		\includegraphics[scale=0.5]{imagens/diagramaClasses.png}
		\label{fig:diagramaClasses}
	\end{center} 
\end{figure}


\subsubsection{Casos de Uso previstos}

A Figura \ref{fig:diagramaCasosUso} contém alguns casos mais comuns de uso do ambiente computacional. Um especialista do conhecimento pode valer-se desse ambiente para aplicá-lo a um problema específico. O objetivo de aplicação pode ser: o aumento na abrangência de regras associadas ao conhecimento inicial do especialista. Cada um dos casos de uso se refere a uma etapa existente neste ciclo, proposto para o aprimoramento das regras provenientes do conhecimento.

\begin{figure}[H] 
	\begin{center}
		\caption{Diagrama de Casos de Uso.}
		\includegraphics[scale=0.5]{imagens/diagramaCasoUso.png}
		\label{fig:diagramaCasosUso}
	\end{center} 
\end{figure}


\subsubsection{Sequência de eventos}

O diagrama de classes da Figura \ref{fig:diagramaSequencia} aponta para a sequência de operações iniciadas pelo usuário, que basicamente, interage através da configuração contida nos arquivos e na interface. O software realiza uma varredura do arquivo que contém as informações necessárias ao desenvolvimento de seus processos.

\begin{figure}[H] 
	\begin{center}
		\caption{Diagrama de Sequência.}
		\includegraphics[scale=0.5]{imagens/diagramaSequencia.png}
		\label{fig:diagramaSequencia}
	\end{center} 
\end{figure}

Como ilustra a Figura \ref{fig:diagramaSequencia}, o software interno atua na modificação da estrutura da RNA geral, quer seja pelo estabelecimento da sua topologia, quer na alteração dessa em consequência da aprendizagem. Uma vez que as operações estejam encerradas, o usuário pode consultar os arquivos produzidos e verificar os resultados.

Os passos à execução do programa podem ser resumidos desta forma:

1. Seleção dos algoritmos, das operações, dos arquivos de dados.

2 A partir dos arquivos de informações inseridos, um conjunto de dados internos de trabalho é produzido pelo programa. Nesse conjunto de dados, podem ser lidos átomos, os mundos aos quais eles pertencem, as devidas posições e recursividades entre eles. 

3 Os cálculos são executados baseados nas informações do passo 2 e se estabelecem a topologia inicial da RNA e suas sub-RNAs, havendo o seu acompanhamento. 

4 Opcionalmente, novas informações podem ser obtidas a partir da leitura de exemplos, durante o aprendizado, alterando e preparando as RNAs aos processos de inferências. 

5 Inicia-se a etapa de dedução lógica. Busca-se a computação convergente do programa, que se reflete na procura da estabilidade do sistema.

\subsubsection{Processos do sistema}

Na Figura XX, podemos acompanhar, de outra forma, as etapas apresentadas nos casos de uso do sistema (Figura \ref{fig:diagramaCasosUso}). Também temos a visão interna da sequência de processos e a atividade de inter-relação entre as classes (Figura XX). Primeiramente, um programa em linguagem lógica será inserido e, conforme a configuração, ocorre o seu processamento inicial.

Existem dois processos relativos à estrutura que entram em operação após a leitura dos dados iniciais: as RNAs são instanciadas e as suas topologias iniciais são fixadas. Logo após, iniciam-se os processos de aprendizagem das RNAs, que podem alterar a forma original da estrutura da rede geral.


Após o processamento da programação, instanciam-se as RNAs correspondentes, assim como os cálculos relativos ao algoritmo em operação. A etapa de aprendizagem das RNAs é executada logo em seguida, finalizando pela obtenção de resultados. Os resultados gerados pelo programa são as RNAs após o processos de aprendizagem e o percentual de acerto obtido individualmente pelas RNAs.

\subsection{Descrição da interface}

A interface também contém um menu para seleção do algoritmo a ser usado, assim como as suas opções de operação dos algoritmos. A aparência da interface está ilustrada pela Figura \ref{fig:telaPrincipal}. A descrição da interface segue nesta seção.

\begin{figure}[H] 
	\begin{center}
		\caption{Tela principal do sistema.}
		\includegraphics[scale=0.5]{imagens/telaPrincipal.png}
		\label{fig:telaPrincipal}
	\end{center} 
\end{figure}


\subsubsection{Painel de edição}

Os três principais arquivos, conforme círculos na Figura X.7, editáveis pela interface são:

1. O arquivo que contém os nomes dos arquivos de trabalho do ambiente computacional (pacote de arquivos).

2. O arquivo que contém o program lógico a ser trabalhado.

3. O arquivo de configuração, que contém as informações sobre como a RNA deve se comportar
durante o aprendizado.
Esses três arquivos são abertos e acessados diretamente no painel interno da interface. Não existe restrição quanto ao tipo de arquivo a ser editado. Arquivos como os de dados a serem utilizados pela RNA também podem ser trabalhados.

\subsubsection{Barra do menu}

Na barra de menu, temos as opções descritas na Tabela \ref{tbl:barraMenu}. As sub-opções relacionadas ao tipo de algoritmo escolhido funcionam como pontos de checagem durante a execução do programa.

\begin{table}[]
	\centering
	\caption{Lista de ações do sistema}
	\label{tbl:barraMenu}
	\begin{tabular}{|l|l|l|}
		\hline
	Operação	& Sub-operações & Descrição \\ \hline
	Backpropagation  &  \\ \hline
	TopGen	&  &  \\ \hline
	 Regras	&  & . \\
                          \\ \hline
	\end{tabular}
\end{table}

Haverá a execução da rotina correspondente no programa sempre que a sub-opção for selecionada e os processos de aprendizagem forem acionados.

\subsubsection{Barra de botões}

A barra de botões da interface facilita algumas operações de edição e execução dos programas. Os espaços (botões ou janela) da barra de botões foram descritos na Tabela \ref{tbl:BarraBotoes}.

\begin{table}[]
	\centering
	\caption{Lista de ações do sistema}
	\label{tbl:BarraBotoes}
	\begin{tabular}{|l|l|l|}
		\hline
		Operação	& Sub-operações & Descrição \\ \hline
		&  &  \\ \hline
		&  &  \\ \hline
		&  &  \\ \hline
	\end{tabular}
\end{table}

\subsubsection{Menu lateral}

A interface também conta com menu \emph{according} localizada nas laterias da janela principal que serve para o acompanhamento do andamento das operações. Esse menu extra possibilita ao usuário identificar o que foi lido do arquivo que contém as regras, saber o resultado final após o treinamento e o TopGen e identificar os níveis (camadas) por cor, as quais os neurônios fazem parte.

\subsection{Considerações sobre as implementações}	

\subsubsection{RNAs}

A maioria dos programas desenvolvidos empregaram as RNAs com o seu aprendizado executado por meio do algoritmo de retro-propagação. A escolha desse algoritmo deveu-se à sua utilização no sistema KBANN [Referencia], possibilitando a comparação de resultados. Os algoritmos que definiram as topologias de RNAs empregadas foram consequência da evolução natural das técnicas de programação.
Os valores de saída e as sinapses da RNA foram implementados por variáveis contidas nas classes Neurônio e Arestas. Quando desejamos acessar o valor contido em um neurônio específico, é utilizado um \emph{HashMap} que possui todos os objetos do tipo neurônio. Dentro de cada neurônio existe uma outra variável que identifica se ele é da camada de entrada, oculta ou saída. Na Figura X.8, é possível ver a representação dessas estruturas com as quais pode-se acessar quaisquer valor desejado no grafo neural construído.

\subsection{Entradas do Sistema}

\subsubsection{Arquivos}

Os arquivos que normalmente são utilizados pelos programas dividem-se em cinco grupos:

1. Arquivos contendo a configuração da RNA e informações de controle do programa.

2. Arquivos contendo os dados de entrada para a RNA (treinamento, validação e teste).

3. Arquivos com as informações sobre a arquitetura da RNA, normalmente os valores dos pesos e as conexões ativas.

4. Os arquivos com o programa lógico.

5. Outros arquivos gerados durante a execução dos programas, e.g., arquivos de avaliação de resultados e de registro ( .log ).

\begin{figure}[H] 
	\begin{center}
		\caption{Arquivo inicial contendo a base de regras}
		\includegraphics[scale=0.5]{imagens/entradaKANN.png}
		\label{fig:entradaKANN}
	\end{center} 
\end{figure}

\subsection{Testes do Sistema}

Para validação do sistema desenvolvido, foi utilizado o software \emph{Matlab} como referência, devido a sua presença no mercado a mais de 45 anos. Para realização do teste, foi necessário montar uma rede de acordo com o que podia ser feito no Matlab. Na Figura \ref{fig:RedeMatlabEstrutura} a sua estrutura pode ser vista. Esse teste teve como intenção apenas que os resultados encontrados no programa fossem parecidos ou próximos do que o Matlab gerava. 

\begin{figure}[H] 
	\begin{center}
		\caption{Tela principal do sistema.}
		\includegraphics[scale=0.5]{imagens/RedeMatlabEstrutura.png}
		\label{fig:RedeMatlabEstrutura}
	\end{center} 
\end{figure}

Como pode ser vista na Figura \ref{fig:RedeMatlabEstrutura}, a rede a ser treinada é uma MLP que possui 4 neurônios na sua entrada, 2 na camada oculta e um na camada de saída. O problema aqui apresentado é de um padrão lógico, ou seja, dados binários. Os dados contidos nesse padrão respondem ao domínio completo, ou seja, como funciona o sistema realmente. Nesse teste foi considerado que a MLP não iria possuir em suas regras todo o conteúdo, sendo assim, foram retiradas 2 regras do domínio apresentado, o que de fato, iria gerar alguns erros na rede ou até mesmo não convergir.

\begin{figure}[H] 
	\begin{center}
		\caption{Estrutura da Rede MLP no Matlab.}
		\includegraphics[scale=0.5]{imagens/RedeMatlabTreinada.png}
		\label{fig:RedeMatlabTreinada}
	\end{center} 
\end{figure}

Pelo o que foi apresentado na Figura \ref{fig:RedeMatlabTreinada}, pode-se observar que o \emph{toolBox} neural do \emph{Matlab} levou 10.000 épocas para finalizar o problema, ou seja, o erro de treinamento ou o erro de validação aceitável não foi obtido, sendo necessário utilizar a quantidade de épocas totais para finalizar o treinamento. Nesse exemplo, foi utilizado o algoritmo de \emph{backpropagation} e a função de ativação dos neurônios escolhida, foi a sigmoide. Outros parâmetros como taxa de aprendizagem, erro aceitável (goal) e o tempo para simulação podem ser verificados na \ref{fig:redeMatlabParametros}.

\begin{figure}[H] 
	\begin{center}
		\caption{Parâmetros da rede MLP treinada.}
		\includegraphics[scale=0.5]{imagens/redeMatlabParametros.png}
		\label{fig:redeMatlabParametros}
	\end{center} 
\end{figure}

As duas últimas figuras (Figura \ref{fig:GraficoErroMatlab} e \ref{fig:errosMatlab}) servem para afirmar o baixo aprendizado para o exemplo fornecido. O erro aceitável ficou longe de ser alcançado e as saídas finais da rede tiveram valores sempre mantidos acima de 0.5, o que demonstra um erro bastante grande. Vale lembrar que os dados passados para treinamento e validação, é a combinação possível para 4 entradas lógicas. Também vale ressaltar que a rede foi treinada com uma teoria de domínio completa. 

\begin{figure}[H] 
	\begin{center}
		\caption{Gráfico do erro de treinamento, validação e teste.}
		\includegraphics[scale=0.5]{imagens/GraficoErroMatlab.png}
			\includegraphics[scale=0.5]{imagens/GraficoErroMatlab.png}
		\label{fig:GraficoErroMatlab}
	\end{center} 
\end{figure}

\begin{figure}[H] 
	\begin{center}
		\caption{Resultados gerados na saída da rede.}
		\includegraphics[scale=0.5]{imagens/errosMatlab.png}
		\label{fig:errosMatlab}
	\end{center} 
\end{figure}




